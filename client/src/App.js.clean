import React, { useEffect, useState, useRef } from 'react';
import io from 'socket.io-client';
import { DndProvider, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';

import Card from './components/Card';
import Deck from './components/Deck';
import Hand from './components/Hand';
import CardDetail from './components/CardDetail';

import styles from './App.module.css';

const socket = io('https://neocard-server.onrender.com');

const ItemTypes = {
  CARD: 'card',
};

const App = () => {
  // State declarations
  const [message, setMessage] = useState('Loading game...');
  const [yourHand, setYourHand] = useState([]);
  const [yourDeckSize, setYourDeckSize] = useState(0);
  const [yourPlayedCards, setYourPlayedCards] = useState([]);
  const [yourManaZone, setYourManaZone] = useState([]);
  const [yourMaxMana, setYourMaxMana] = useState(0);
  const [yourCurrentMana, setYourCurrentMana] = useState(0);
  const [yourLife, setYourLife] = useState(20);
  const [opponentPlayedCards, setOpponentPlayedCards] = useState([]);
  const [opponentManaZone, setOpponentManaZone] = useState([]);
  const [opponentDeckSize, setOpponentDeckSize] = useState(0);
  const [opponentMaxMana, setOpponentMaxMana] = useState(0);
  const [opponentCurrentMana, setOpponentCurrentMana] = useState(0);
  const [opponentLife, setOpponentLife] = useState(20);
  const [isYourTurn, setIsYourTurn] = useState(false);
  const [selectedCardDetail, setSelectedCardDetail] = useState(null);
  const [effectMessage, setEffectMessage] = useState(null);
  const [currentPhase, setCurrentPhase] = useState('main_phase_1');
  const [attackingCreatures, setAttackingCreatures] = useState([]);
  const [blockingAssignments, setBlockingAssignments] = useState({});
  const [selectedAttackerCardId, setSelectedAttackerCardId] = useState(null);
  const [selectedBlockerCardId, setSelectedBlockerCardId] = useState(null);

  // Refs
  const isYourTurnRef = useRef(isYourTurn);
  
  // Effects
  useEffect(() => {
    isYourTurnRef.current = isYourTurn;
  }, [isYourTurn]);

  useEffect(() => {
    socket.on('connect', () => {
      setMessage('Connected to server!');
      socket.emit('request_game_state');
    });

    socket.on('disconnect', () => {
      setMessage('Disconnected from server.');
    });

    socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
      setMessage(`Connection error: ${error.message}. Retrying...`);
    });

    socket.on('game_state', (state) => {
      console.log('[App.js] Received game state:', state);
      setYourHand(state.yourHand || []);
      setYourDeckSize(state.yourDeckSize);
      setYourPlayedCards(state.yourPlayedCards || []);
      setYourManaZone(state.yourManaZone || []);
      setYourMaxMana(state.yourMaxMana);
      setYourCurrentMana(state.yourCurrentMana);
      setOpponentPlayedCards(state.opponentPlayedCards || []);
      setOpponentManaZone(state.opponentManaZone || []);
      setOpponentDeckSize(state.opponentDeckSize);
      setOpponentMaxMana(state.opponentMaxMana);
      setOpponentCurrentMana(state.opponentCurrentMana);
      setYourLife(state.yourLife);
      setOpponentLife(state.opponentLife);
      setIsYourTurn(state.isYourTurn);
      setCurrentPhase(state.currentPhase);
      setAttackingCreatures(state.attackingCreatures || []);
      setBlockingAssignments(state.blockingAssignments || {});
    });

    socket.on('effect_triggered', (message) => {
      setEffectMessage(message);
      setTimeout(() => setEffectMessage(null), 3000);
    });

    return () => {
      socket.off('connect');
      socket.off('disconnect');
      socket.off('connect_error');
      socket.off('game_state');
      socket.off('effect_triggered');
    };
  }, []);

  // Event handlers
  const handleNextPhase = () => {
    socket.emit('next_phase');
  };

  const handleCardAction = (card, action) => {
    if (action === 'attack') {
      socket.emit('card_action', { cardId: card.id, action });
    } else if (action === 'block') {
      socket.emit('card_action', { 
        cardId: selectedBlockerCardId, 
        action: 'block', 
        attackerId: selectedAttackerCardId 
      });
    } else {
      socket.emit('card_action', { cardId: card.id, action });
    }
  };

  const handleTargetClick = (cardId) => {
    if (currentPhase === 'declare_blockers' && !isYourTurn) {
      setSelectedBlockerCardId(cardId);
    } else if (currentPhase === 'declare_attackers' && isYourTurn) {
      setSelectedAttackerCardId(cardId);
    }
  };

  // Render functions
  const renderCard = (card, index, isPlayed = false, isOpponent = false) => {
    if (!card) return null;
    
    const isAttacking = attackingCreatures.some(a => a.attackerId === card.id);
    const isBlocking = Object.values(blockingAssignments).some(blockers => 
      blockers && blockers.includes(card.id)
    );

    const isSelectableBlocker = 
      !isYourTurn && 
      currentPhase === 'declare_blockers' && 
      isPlayed && 
      !card.isTapped && 
      !isBlocking;

    const isAttackable = 
      isYourTurn && 
      currentPhase === 'declare_attackers' && 
      isPlayed && 
      !card.isTapped &&
      !isAttacking;

    return (
      <div 
        key={card.id}
        className={`card-container ${isSelectableBlocker ? 'selectable-blocker' : ''} ${isAttackable ? 'selectable-attacker' : ''}`}
        onClick={() => {
          if (isSelectableBlocker) {
            setSelectedBlockerCardId(card.id);
          } else if (isAttackable) {
            handleCardAction(card, 'attack');
          } else if (currentPhase === 'declare_blockers' && !isYourTurn && selectedBlockerCardId === card.id) {
            setSelectedBlockerCardId(null);
          }
        }}
      >
        <Card
          id={card.id}
          value={card.value}
          manaCost={card.manaCost}
          imageUrl={card.imageUrl}
          name={card.name}
          effect={card.effect}
          description={card.description}
          attack={card.attack}
          defense={card.defense}
          onCardAction={handleCardAction}
          isPlayed={isPlayed}
          isYourTurn={isYourTurn}
          hasAttackedThisTurn={card.hasAttackedThisTurn}
          isAttacking={isAttacking}
          isBlocking={isBlocking}
          isTapped={card.isTapped}
          onTargetClick={handleTargetClick}
          isOpponent={isOpponent}
        />
        {isSelectableBlocker && (
          <div className="blocker-overlay">
            <span>BLOCK</span>
          </div>
        )}
      </div>
    );
  };

  const renderGameInfo = () => {
    return (
      <div className="game-info">
        {effectMessage && (
          <div className="effect-message">
            {effectMessage}
          </div>
        )}
        <div className="phase-controls">
          <button 
            className="next-phase-button"
            onClick={handleNextPhase}
            disabled={currentPhase === 'declare_blockers' && !isYourTurn}
          >
            {currentPhase === 'declare_attackers' ? '攻撃宣言を確定' : '次のフェーズへ'}
          </button>
          <div className="current-phase">
            Current Phase: {currentPhase.replace(/_/g, ' ').toUpperCase()}
          </div>
        </div>
      </div>
    );
  };

  // Drop targets
  const [{ isOverYourField }, dropYourField] = useDrop(() => ({
    accept: ItemTypes.CARD,
    drop: (item, monitor) => {
      console.log('Card dropped on Your Field:', item.id);
      handleCardAction(item, 'play');
    },
    collect: (monitor) => ({
      isOverYourField: !!monitor.isOver(),
    }),
  }));

  const [{ isOverYourMana }, dropYourMana] = useDrop(() => ({
    accept: ItemTypes.CARD,
    drop: (item, monitor) => {
      console.log('Card dropped on Your Mana:', item.id);
      handleCardAction(item, 'tap_for_mana');
    },
    collect: (monitor) => ({
      isOverYourMana: !!monitor.isOver(),
    }),
  }));

  const [{ isOverOpponentMana }, dropOpponentMana] = useDrop(() => ({
    accept: ItemTypes.CARD,
    drop: (item, monitor) => {
      console.log('Card dropped on Opponent Mana:', item.id);
      alert("You cannot play cards to opponent's mana zone!");
    },
    collect: (monitor) => ({
      isOverOpponentMana: !!monitor.isOver(),
    }),
  }));

  const [{ isOverOpponentField }, dropOpponentField] = useDrop(() => ({
    accept: ItemTypes.CARD,
    drop: (item, monitor) => {
      console.log('Card dropped on Opponent Field:', item.id);
      alert("You cannot play cards to opponent's field!");
    },
    collect: (monitor) => ({
      isOverOpponentField: !!monitor.isOver(),
    }),
  }));

  // Main render
  return (
    <DndProvider backend={HTML5Backend}>
      <div className={styles.appContainer}>
        <style jsx global>{`
          .selectable-blocker {
            box-shadow: 0 0 10px 5px rgba(0, 255, 0, 0.5);
            transform: translateY(-5px);
            transition: all 0.2s ease;
          }
          
          .selectable-attacker {
            box-shadow: 0 0 10px 5px rgba(255, 0, 0, 0.5);
            transform: translateY(-5px);
            transition: all 0.2s ease;
          }
          
          .card-container {
            position: relative;
            transition: all 0.2s ease;
            margin: 5px;
          }
          
          .card-container:hover {
            transform: translateY(-5px);
          }
          
          .game-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
          }
          
          .phase-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
          }
          
          .next-phase-button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
          }
          
          .next-phase-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
          }
          
          .current-phase {
            font-size: 14px;
            opacity: 0.8;
          }
          
          .effect-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1001;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            animation: fadeInOut 3s ease-in-out;
            white-space: nowrap;
            font-size: 1.2em;
            font-weight: bold;
          }
          
          .blocker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 255, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            pointer-events: none;
          }
          
          .blocker-overlay span {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
          }
          
          @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
          }
        `}</style>

        <h1>{message}</h1>
        
        <div className={styles.gameArea}>
          {/* Opponent's Area */}
          <div className={styles.opponentArea}>
            <h3>Opponent's Area</h3>
            <p>Opponent's Life: {opponentLife}</p>
            
            <h4>Opponent's Played Cards:</h4>
            <div 
              ref={dropOpponentField}
              className={`${styles.playedCardsArea} ${isOverOpponentField ? styles.playedCardsAreaOver : ''}`}
            >
              {opponentPlayedCards.length === 0 ? (
                <p className={styles.emptyZoneText}>No cards played by opponent.</p>
              ) : (
                opponentPlayedCards.map(card => renderCard(card, card.id, true, true))
              )}
            </div>

            <div className={styles.manaZoneContainer}>
              <p>Opponent's Mana: {opponentCurrentMana} / {opponentMaxMana}</p>
              <h4>Opponent's Mana Zone:</h4>
              <div 
                ref={dropOpponentMana}
                className={`${styles.manaZone} ${isOverOpponentMana ? styles.manaZoneOver : ''}`}
              >
                {opponentManaZone.length === 0 ? (
                  <p className={styles.emptyZoneText}>Empty</p>
                ) : (
                  opponentManaZone.map(card => (
                    <Card 
                      key={card.id}
                      id={card.id}
                      value={card.value}
                      manaCost={card.manaCost}
                      imageUrl={card.imageUrl}
                      name={card.name}
                      effect={card.effect}
                      description={card.description}
                      attack={card.attack}
                      defense={card.defense}
                      onCardAction={handleCardAction}
                    />
                  ))
                )}
              </div>
            </div>
          </div>

          {/* Your Area */}
          <div className={styles.yourArea}>
            <h3>Your Area</h3>
            <p>Your Life: {yourLife}</p>
            
            <h4>Your Played Cards:</h4>
            <div
              ref={dropYourField}
              className={`${styles.playedCardsArea} ${isOverYourField ? styles.playedCardsAreaOver : ''}`}
            >
              {yourPlayedCards.length === 0 ? (
                <p className={styles.emptyZoneText}>No cards played by you.</p>
              ) : (
                yourPlayedCards.map(card => renderCard(card, card.id, true, false))
              )}
            </div>

            <div className={styles.manaHandContainer}>
              <div className={styles.manaZoneContainer}>
                <p>Your Mana: {yourCurrentMana} / {yourMaxMana}</p>
                <h4>Your Mana Zone:</h4>
                <div
                  ref={dropYourMana}
                  className={`${styles.manaZone} ${isOverYourMana ? styles.manaZoneOver : ''}`}
                >
                  {yourManaZone.length === 0 ? (
                    <p className={styles.emptyZoneText}>Empty</p>
                  ) : (
                    yourManaZone.map(card => (
                      <Card 
                        key={card.id}
                        id={card.id}
                        value={card.value}
                        manaCost={card.manaCost}
                        imageUrl={card.imageUrl}
                        name={card.name}
                        effect={card.effect}
                        description={card.description}
                        attack={card.attack}
                        defense={card.defense}
                        onCardAction={handleCardAction}
                      />
                    ))
                  )}
                </div>
              </div>

              <div className={styles.handContainer}>
                <h4>Your Hand:</h4>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '5px' }}>
                  {yourHand.map((card, index) => renderCard(card, index, false, false))}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Game Info */}
        {renderGameInfo()}

        {/* Card Detail */}
        {selectedCardDetail && (
          <CardDetail 
            card={selectedCardDetail} 
            onClose={() => setSelectedCardDetail(null)} 
          />
        )}

        {/* Effect Message */}
        {effectMessage && (
          <div className="effect-message">
            {effectMessage}
          </div>
        )}
      </div>
    </DndProvider>
  );
};

export default App;
